@page "/"
@using DexResearchArbitrage.Models
@using DexResearchArbitrage.Services
@using DexResearchArbitrage.Components
@using System.Text.Json
@using System.Threading

@inject HttpClient Http
@inject IDialogService DialogService
@inject IJSRuntime JSRuntime
@inject ITokenValidationService TokenValidationService
@inject IPoolsService PoolsService
@inject ITokenPriceService TokenPriceService
@inject IBalancesService BalancesService
@inject ISwapsService SwapsService

<MudPaper Class="pa-4">
    <MudText Typo="Typo.h5">DEX Pool Explorer</MudText>
    <MudDivider Class="my-2" />
    
    <!-- Network and Token Input Section -->
    <MudGrid Class="mb-4">
        <MudItem xs="12" md="4">
            <MudSelect T="Network"
                       Label="Select Network"
                       Value="selectedNetwork"
                       ValueChanged="OnNetworkChanged"
                       ValueExpression="() => selectedNetwork"
                       Required="true"
                       RequiredError="Please select a network"
                       Variant="Variant.Outlined"
                       AnchorOrigin="Origin.BottomCenter">
                <MudSelectItem Value="Network.None" Disabled="true">-- Select Network --</MudSelectItem>
                <MudSelectItem Value="Network.Solana">Solana</MudSelectItem>
                <MudSelectItem Value="Network.Ethereum">Ethereum</MudSelectItem>
            </MudSelect>
        </MudItem>
        
        <MudItem xs="12" md="6">
            <MudTextField @bind-Value="tokenAddress"
                          Label="Token Address"
                          Placeholder="Enter or paste token address"
                          Variant="Variant.Outlined"
                          Immediate="false"
                          OnBlur="OnTokenAddressBlur"
                          Disabled="@(selectedNetwork == Network.None)"
                          Error="@hasValidationError"
                          ErrorText="@validationErrorMessage"
                          Adornment="Adornment.End"
                          AdornmentIcon="@(isValidating ? Icons.Material.Filled.HourglassEmpty : Icons.Material.Filled.Search)"
                          AdornmentColor="Color.Primary" />
        </MudItem>
        
        <MudItem xs="12" md="2" Class="d-flex align-center">
            <MudButton Variant="Variant.Filled" 
                       Color="Color.Primary" 
                       OnClick="ValidateAndLoadPools"
                       Disabled="@(selectedNetwork == Network.None || string.IsNullOrWhiteSpace(tokenAddress) || isValidating || isLoadingPools)">
                @if (isValidating || isLoadingPools)
                {
                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                    <span>Loading...</span>
                }
                else
                {
                    <span>Search Pools</span>
                }
            </MudButton>
        </MudItem>
    </MudGrid>
    
    <!-- Validated Token Info -->
    @if (validatedToken != null && validatedToken.IsValid)
    {
        <MudAlert Severity="Severity.Success" Class="mb-4" Dense="true">
            Token validated: @validatedToken.TokenSymbol (@validatedToken.TokenAddress)
        </MudAlert>
    }
    
    <!-- Filters Section -->
    @if (selectedNetwork != Network.None)
    {
        <PoolFilters Filters="@filters" 
                     AvailableSecondTokens="@availableSecondTokens"
                     OnFiltersChanged="OnFiltersChangedHandler" />
    }
    
    <!-- Pools Table -->
    @if (allPools.Count > 0)
    {
       <MudTable Items="@filteredPools" 
          T="PoolInfo" 
          Hover="true"
          Bordered="true"
          Breakpoint="Breakpoint.Sm"
          FixedHeader="true"
          Height="calc(100vh - 450px)"
          Dense="true"
          OnRowClick="OnPoolRowClick"
          RowStyleFunc="@SelectedRowStyleFunc"
          @bind-SelectedItem="selectedPool">
    <HeaderContent>
        <MudTh Style="width: 50px;">№</MudTh>
        <MudTh>DEX</MudTh>
        <MudTh>Pool Address</MudTh>
        <MudTh>Second Token</MudTh>

        <MudTh>
            <MudIconButton Icon="@Icons.Material.Filled.Refresh"
                           Size="Size.Small"
                           Color="Color.Default"
                           Class="mr-1"
                           OnClick="OnRefreshTvlClicked" />
            TVL (USD)
        </MudTh>

        <MudTh>
            <MudIconButton Icon="@Icons.Material.Filled.Refresh"
                           Size="Size.Small"
                           Color="Color.Default"
                           Class="mr-1"
                           OnClick="OnRefreshSwapsClicked" />
            Swaps Count
        </MudTh>

        <MudTh>
            <MudIconButton Icon="@Icons.Material.Filled.Refresh"
                           Size="Size.Small"
                           Color="Color.Default"
                           Class="mr-1"
                           OnClick="OnRefreshLatestPriceClicked" />
            LatestPrice
        </MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd DataLabel="№">@(filteredPools.IndexOf(context) + 1)</MudTd>
        <MudTd DataLabel="DEX">@context.Dex</MudTd>
        <MudTd DataLabel="Pool Address">
            <div class="d-flex align-center">
                <MudTooltip Text="@context.PoolAddress">
                    <span>@TruncateAddress(context.PoolAddress)</span>
                </MudTooltip>
                <MudIconButton Icon="@Icons.Material.Filled.ContentCopy"
                               Size="Size.Small"
                               Color="Color.Default"
                               Class="ml-1"
                               OnClick="@(() => CopyPoolAddressAsync(context.PoolAddress))" />
            </div>
        </MudTd>
        <MudTd DataLabel="Second Token">
            @if (!string.IsNullOrEmpty(context.SecondTokenSymbol))
            {
                <MudTooltip Text="@context.SecondTokenAddress">
                    <span>@context.SecondTokenSymbol</span>
                </MudTooltip>
            }
            else
            {
                <MudTooltip Text="@context.SecondTokenAddress">
                    <span>@TruncateAddress(context.SecondTokenAddress)</span>
                </MudTooltip>
            }
        </MudTd>
        <MudTd DataLabel="TVL (USD)">
            @if (context.IsTvlLoading)
            {
                <MudProgressCircular Size="Size.Small" Indeterminate="true" />
            }
            else
            {
                @context.TvlUsd.ToString("N2")
            }
        </MudTd>

        <MudTd DataLabel="Swaps Count">
            @if (context.IsSwapsLoading)
            { 
                <MudProgressCircular Size="Size.Small" Indeterminate="true" />
            }
             else
            { 
                @context.CountSwaps
            }
         </MudTd>

        <MudTd DataLabel="LatestPrice">
            @if (context.LatestPricePriceUsd > 0)
            {
                @context.LatestPricePriceUsd.ToString("F6")
            }
            else
            {
                <span>-</span>
            }
        </MudTd>
    </RowTemplate>
</MudTable>

        
        <!-- Total Records Info -->
        <MudPaper Class="pa-2 mt-2" Elevation="0">
            <MudText Typo="Typo.body2">
                Total records: <strong>@filteredPools.Count</strong>
                @if (filters.HasActiveFilters())
                {
                    <span> (filtered from @allPools.Count)</span>
                }
            </MudText>
        </MudPaper>
    }
    else if (isLoadingPools)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="my-4" />
        <MudText Align="Align.Center">Loading pools...</MudText>
    }
    else if (validatedToken != null && validatedToken.IsValid && allPools.Count == 0)
    {
        <MudAlert Severity="Severity.Info" Class="mt-4">
            No pools found for this token on @selectedNetwork.ToDisplayString().
        </MudAlert>
    }
</MudPaper>

@code {
    // State
    // Special pool for wSOL-USDC price
    private const string WsolUsdcPoolAddress = "21gTfxAnhUDjJGZJDkTXctGFKT8TeiXx6pN1CEg9K1uW";
    private const string WethUsdtPoolAddress = "0x4e68Ccd3E89f51C3074ca5072bbAC773960dFa36";


    // Cached wSOL or wETH price in USD per swap
    private List<SwapPricePoint> _baseTokenUsdPriceHistory = new();

    private Network selectedNetwork = Network.None;
    private string tokenAddress = string.Empty;
    private TokenValidationResult? validatedToken;

    // Pools data
    private List<PoolInfo> allPools = new();
    private List<PoolInfo> filteredPools = new();
    private PoolInfo? selectedPool;
    
    // Filters
    private PoolFiltersModel filters = new();
    private List<string> availableSecondTokens = new();

    // UI state
    private bool isValidating = false;
    private bool isLoadingPools = false;
    private bool hasValidationError = false;
    private string validationErrorMessage = string.Empty;

    // Predefined Solana secondary tokens for filters
    private readonly Dictionary<string, string> _predefinedSolanaSecondTokens =
        new()
        {
            { "So11111111111111111111111111111111111111112", "wSOL" },
            { "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB", "USDT" },
            { "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", "USDC" }
        };

    // Predefined Ethereum secondary tokens for filters
    private readonly Dictionary<string, string> _predefinedEthereumSecondTokens =
        new()
        {
            { "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", "wETH" },
            { "0xdAC17F958D2ee523a2206206994597C13D831ec7", "USDT" },
            { "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", "USDC" }
        };    

    protected override void OnInitialized()
    {
        SetDefaultFilters();
    }

   private void SetDefaultFilters()
    {
        // Set default filters Data
        filters.SwapsFromDate = DateTime.UtcNow.Date.AddDays(-2);

        // MinSwapCount default = 0
        filters.MinSwapCount = 0;
    }

    private async Task OnFiltersChangedHandler()
    {
        // Validate date limit (Demo version restriction: max 2 days history)
        if (filters.SwapsFromDate.HasValue)
        {
            var minAllowedDate = DateTime.UtcNow.Date.AddDays(-2);
            
            if (filters.SwapsFromDate.Value < minAllowedDate)
            {
                // Show warning dialog
                var msg = $"Demo version allows filtering no later than {minAllowedDate:yyyy-MM-dd} (max 2 days ago).";
                await DialogService.ShowMessageBox("Demo Limitation", msg, yesText: "OK");

                // Reset to minimum allowed date
                filters.SwapsFromDate = minAllowedDate;
            }
        }

        // Apply filters normally
        filteredPools = FilterPools(allPools, filters);
        StateHasChanged();
    }

    private void OnNetworkChanged(Network value)
    {
        selectedNetwork = value;

        // Reset state when network changes
        tokenAddress = string.Empty;
        validatedToken = null;
        allPools.Clear();
        filteredPools.Clear();
        hasValidationError = false;
        validationErrorMessage = string.Empty;

        filters.Reset();
        SetDefaultFilters();

        UpdateAvailableSecondTokens();
        StateHasChanged();
    }

    private void UpdateAvailableSecondTokens()
    {
        availableSecondTokens.Clear();

        if (selectedNetwork == Network.Solana)
        {
            foreach (var kvp in _predefinedSolanaSecondTokens)
            {
                var addr = kvp.Key;
                var symbol = kvp.Value;
                var display = $"{symbol} ({TruncateAddress(addr)})";
                availableSecondTokens.Add(display);
            }
        }
        else if (selectedNetwork == Network.Ethereum)
        {
             foreach (var kvp in _predefinedEthereumSecondTokens)
            {
                var addr = kvp.Key;
                var symbol = kvp.Value;
                var display = $"{symbol} ({TruncateAddress(addr)})";
                availableSecondTokens.Add(display);
            }
        }
        else
        {
            // For other networks we currently do not define predefined tokens.
            availableSecondTokens.Clear();
        }
    }

    private Task OnTokenAddressBlur()
    {
        // Optional: auto-validate on blur in the future.
        return Task.CompletedTask;
    }

    private async Task CopyPoolAddressAsync(string address)
    {
        try
        {
            var ok = await JSRuntime.InvokeAsync<bool>("copyToClipboard", address);
            Console.WriteLine(ok
                ? $"Pool address copied: {address}"
                : "Clipboard copy returned false");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Clipboard copy error: {ex.Message}");
        }
    }

    private async Task ValidateAndLoadPools()
    {
        if (selectedNetwork == Network.None || string.IsNullOrWhiteSpace(tokenAddress))
            return;

        // Reset state
        hasValidationError = false;
        validationErrorMessage = string.Empty;
        allPools.Clear();
        filteredPools.Clear();
        filters.Reset();
        SetDefaultFilters();

        // Step 1: Validate token
        isValidating = true;
        StateHasChanged();

        try
        {
            validatedToken = await TokenValidationService.ValidateTokenAsync(selectedNetwork, tokenAddress.Trim());

            if (!validatedToken.IsValid)
            {
                await ShowInvalidTokenDialog(validatedToken.ErrorMessage ?? "Invalid token address");

                tokenAddress = string.Empty;
                hasValidationError = true;
                validationErrorMessage = validatedToken.ErrorMessage ?? "Invalid token address";
                validatedToken = null;

                isValidating = false;
                StateHasChanged();
                return;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Validation error: {ex.Message}");
            hasValidationError = true;
            validationErrorMessage = "Error validating token";
            isValidating = false;
            StateHasChanged();
            return;
        }

        isValidating = false;

        // Step 2: Load pools
        isLoadingPools = true;
        StateHasChanged();

        try
        {
            allPools = await PoolsService.GetPoolsByTokenAsync(selectedNetwork, tokenAddress.Trim());

            // availableSecondTokens already prepared by UpdateAvailableSecondTokens (for Solana and Ethereum).
            ApplyFilters();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading pools: {ex.Message}");
        }
        finally
        {
            isLoadingPools = false;
            StateHasChanged();
        }
    }

    private void ApplyFilters()
    {
        filteredPools = FilterPools(allPools, filters);
        StateHasChanged();
    }

    /// <summary>
    /// Client-side filtering logic (separated for testability).
    /// </summary>
    private List<PoolInfo> FilterPools(List<PoolInfo> pools, PoolFiltersModel filterModel)
    {
        var result = pools.AsEnumerable();

        // Filter by predefined second tokens (wSOL/USDT/USDC for Solana, wETH/USDT/USDC for Ethereum).
        if (filterModel.SecondTokenAddresses.Count > 0)
        {
            var selectedAddresses = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            foreach (var selected in filterModel.SecondTokenAddresses)
            {
                if (selectedNetwork == Network.Solana)
                {
                    foreach (var kvp in _predefinedSolanaSecondTokens)
                    {
                        var addr = kvp.Key;
                        var symbol = kvp.Value;
                        if (selected.StartsWith(symbol + " ", StringComparison.OrdinalIgnoreCase))
                        {
                            selectedAddresses.Add(addr);
                        }
                    }
                }
                else if (selectedNetwork == Network.Ethereum)
                {
                    foreach (var kvp in _predefinedEthereumSecondTokens)
                    {
                        var addr = kvp.Key;
                        var symbol = kvp.Value;
                        if (selected.StartsWith(symbol + " ", StringComparison.OrdinalIgnoreCase))
                        {
                            selectedAddresses.Add(addr);
                        }
                    }
                }
            }

            if (selectedAddresses.Count > 0)
            {
                result = result.Where(p => selectedAddresses.Contains(p.SecondTokenAddress));
            }
        }

        // Filter by minimum TVL
        if (filterModel.MinTvlUsd > 0)
        {
            result = result.Where(p => p.TvlUsd >= filterModel.MinTvlUsd);
        }

        // Filter by swaps count
        if (filterModel.MinSwapCount > 0)
        {
            result = result.Where(p => p.CountSwaps >= filterModel.MinSwapCount);
        }

        // Date filter is temporarily disabled. SwapsFromDate will be used by another procedure later.
        // if (filterModel.SwapsFromDate.HasValue)
        // {
        //     result = result.Where(p =>
        //         p.LastSwapTimestamp.HasValue &&
        //         p.LastSwapTimestamp.Value >= filterModel.SwapsFromDate.Value);
        // }

        // Filter by price difference percentage
        if (filterModel.MinPriceDiffPercent > 0)
        {
            result = result.Where(p => p.PriceDiffPercent >= filterModel.MinPriceDiffPercent);
        }

        return result.ToList();
    }

    private async Task ShowInvalidTokenDialog(string message)
    {
        var parameters = new DialogParameters
        {
            { "Message", message }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            CloseOnEscapeKey = true
        };

        await DialogService.ShowAsync<InvalidTokenDialog>("Invalid Token", parameters, options);
    }

    private void OnPoolRowClick(TableRowClickEventArgs<PoolInfo> args)
    {
        selectedPool = args.Item;

        // TODO: Implement pool click action (e.g., navigate to pool details, open external link).
        Console.WriteLine($"Pool clicked: {args.Item?.PoolAddress}");

        HandlePoolSelection(args.Item);
    }

    /// <summary>
    /// Extension point for handling pool selection.
    /// </summary>
    private void HandlePoolSelection(PoolInfo? pool)
    {
        if (pool == null) return;

        // TODO: Implement desired action:
        // - Navigate to pool details page
        // - Open pool in DEX explorer
        // - Show pool details dialog
        // - etc.
    }

        private async void OnRefreshTvlClicked()
    {
        // 1. Убрали проверку "только Solana". Теперь работает для всех сетей.
        if (selectedNetwork == Network.None)
            return;

        filters.MinTvlUsd = 0;

        // Проверка: выбран ли хоть один фильтр
        if (filters.SecondTokenAddresses.Count == 0)
        {
            await DialogService.ShowMessageBox(
                "Warning",
                "To refresh TVL, please apply the Second Token filter and select at least one of the secondary tokens (e.g. USDT, USDC, wETH/wSOL).",
                yesText: "OK");
            return;
        }

        // Проверка: применен ли фильтр к таблице
        if (filteredPools.Count == 0 || filteredPools.Count == allPools.Count)
        {
            await DialogService.ShowMessageBox(
                "Warning",
                "Second Token filter is not applied to the table. Click 'Apply' in filters and try again.",
                yesText: "OK");
            return;
        }

        // Собираем список адресов для проверки (разный для Solana и Ethereum)
        var selectedAddresses = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        
        foreach (var selected in filters.SecondTokenAddresses)
        {
            if (selectedNetwork == Network.Solana)
            {
                foreach (var kvp in _predefinedSolanaSecondTokens)
                {
                    if (selected.StartsWith(kvp.Value + " ", StringComparison.OrdinalIgnoreCase))
                        selectedAddresses.Add(kvp.Key);
                }
            }
            else if (selectedNetwork == Network.Ethereum)
            {
                foreach (var kvp in _predefinedEthereumSecondTokens)
                {
                    if (selected.StartsWith(kvp.Value + " ", StringComparison.OrdinalIgnoreCase))
                        selectedAddresses.Add(kvp.Key);
                }
            }
        }

        if (selectedAddresses.Count == 0)
        {
            await DialogService.ShowMessageBox(
                "Warning",
                "Unable to resolve selected Second Token filters. Please reselect them.",
                yesText: "OK");
            return;
        }

        // Включаем спиннеры
        foreach (var pool in filteredPools)
        {
            pool.IsTvlLoading = true;
            pool.TvlUsd = 0;
        }
        StateHasChanged();

        try
        {
            foreach (var pool in filteredPools)
            {
                try
                {
                    // Если пул не соответствует выбранным токенам (защита, хотя выше мы уже фильтровали таблицу)
                    if (!selectedAddresses.Contains(pool.SecondTokenAddress))
                    {
                        pool.TvlUsd = 0;
                        pool.IsTvlLoading = false;
                        StateHasChanged();
                        continue;
                    }

                    // --- ИЗМЕНЕНИЕ ЗДЕСЬ: Передаем selectedNetwork ---
                    var balances = await BalancesService.GetAddressTokensBalanceAsync(selectedNetwork, pool.PoolAddress, 20);
                    
                    if (balances == null || balances.Data == null || balances.Data.Count == 0)
                    {
                        pool.TvlUsd = 0;
                        pool.IsTvlLoading = false;
                        StateHasChanged();
                        continue;
                    }

                    // Ищем баланс нашего вторичного токена
                    var match = balances.Data.FirstOrDefault(x =>
                        x.TokenAddress.Equals(pool.SecondTokenAddress, StringComparison.OrdinalIgnoreCase));

                    // Берем amount_usd и умножаем на 2 (классическая формула TVL V2 пулов)
                    if (match != null && match.AmountUsd.HasValue)
                        pool.TvlUsd = 2.0m * match.AmountUsd.Value;
                    else
                        pool.TvlUsd = 0;

                    pool.IsTvlLoading = false;
                    StateHasChanged();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[TVL] Error recalculating for pool {pool.PoolAddress}: {ex.Message}");
                    pool.TvlUsd = 0;
                    pool.IsTvlLoading = false;
                    StateHasChanged();
                }
            }
        }
        finally
        {
            // Do not disable globally
        }
    }


        private async Task ProcessPoolSwapsAsync(PoolInfo pool, DateTime? fromDate)
    {
        // Local retry function
        async Task<dynamic?> FetchSwapsWithRetry()
        {
            const int MaxRetries = 3;
            for (int i = 0; i < MaxRetries; i++)
            {
                try
                {
                    // Pass selectedNetwork as the first argument
                    var res = await SwapsService.GetPoolSwapsAsync(selectedNetwork, pool.PoolAddress, 3000);
                    if (res != null && res.Data != null) return res.Data;
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Retry {i+1} for {pool.PoolAddress}: {ex.Message}");
                    if (i == MaxRetries - 1) throw;
                    await Task.Delay(1000 * (i + 1));
                }
            }
            return null;
        }

        try
        {
            var from = fromDate?.Date ?? DateTime.MinValue;
            var to = DateTime.UtcNow;

            // 1. Fetch Data
            dynamic? swapsData = await FetchSwapsWithRetry();

            // Check for null explicitly to avoid CS8602
            if (swapsData == null)
            {
                pool.CountSwaps = 0;
                pool.LatestPricePriceUsd = 0;
                return; // Finally block handles IsSwapsLoading
            }

            // Check for empty collection
            if (swapsData.Count == 0)
            {
                pool.CountSwaps = 0;
                pool.LatestPricePriceUsd = 0;
                return;
            }

            // 2. Prepare for calculation
            var firstTokenAddress = validatedToken?.TokenAddress ?? string.Empty;
            var secondTokenAddress = pool.SecondTokenAddress;
            
            // Optimization: Pre-calculate diff index
            int diffIndex = 0;
            int minLen = Math.Min(firstTokenAddress.Length, secondTokenAddress.Length);
            while (diffIndex < minLen &&
                   firstTokenAddress[diffIndex] == secondTokenAddress[diffIndex])
            {
                diffIndex++;
            }
            
            // Determine price calculation strategy based on the secondary token
            int priceCalculationType = 0; // 0 = Unknown/No calc, 1 = Direct USD, 2 = Via Base Token (wSOL/wETH)

            if (selectedNetwork == Network.Solana)
            {
                // USDC or USDT
                if (secondTokenAddress == "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" || 
                    secondTokenAddress == "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB")
                {
                    priceCalculationType = 1; 
                }
                // wSOL
                else if (secondTokenAddress == "So11111111111111111111111111111111111111112")
                {
                    priceCalculationType = 2; 
                }
            }
            else if (selectedNetwork == Network.Ethereum)
            {
                // USDT or USDC (Ethereum addresses)
                if (string.Equals(secondTokenAddress, "0xdAC17F958D2ee523a2206206994597C13D831ec7", StringComparison.OrdinalIgnoreCase) || 
                    string.Equals(secondTokenAddress, "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", StringComparison.OrdinalIgnoreCase))
                {
                    priceCalculationType = 1;
                }
                // wETH
                else if (string.Equals(secondTokenAddress, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", StringComparison.OrdinalIgnoreCase))
                {
                    priceCalculationType = 2;
                }
            }

            var pricePoints = new List<SwapPricePoint>();
            int countInRange = 0;

            // 3. Calculation Loop
            foreach (var s in swapsData)
            {
                // Explicit null check for loop item
                if (s == null) continue;
                
                DateTime ts = s.Timestamp;
                
                // Filter by date
                if (ts < from || ts > to) continue;

                countInRange++;

                if (priceCalculationType == 0) continue;

                decimal? priceFirstPerSecond = null;
                string? sFrom = s.FromTokenAddress;
                
                if (string.IsNullOrEmpty(sFrom)) continue;

                // Fast comparison
                bool fromIsFirst = sFrom.Length > diffIndex && firstTokenAddress.Length > diffIndex && 
                                   sFrom[diffIndex] == firstTokenAddress[diffIndex];
                
                decimal sFromAmt = s.FromTokenAmount;
                decimal sToAmt = s.ToTokenAmount;

                if (fromIsFirst && sFromAmt != 0)
                    priceFirstPerSecond = sToAmt / sFromAmt;
                else if (!fromIsFirst && sToAmt != 0)
                    priceFirstPerSecond = sFromAmt / sToAmt;

                if (!priceFirstPerSecond.HasValue) continue;

                decimal priceUsd = 0;
                if (priceCalculationType == 1)
                {
                    // Direct USD pair
                    priceUsd = priceFirstPerSecond.Value;
                }
                else
                {
                    // Pair via Base Token (wSOL or wETH)
                    // Ensure you have renamed GetClosestWsolUsdPrice to GetClosestBaseTokenPrice 
                    // or use the old name if you kept it.
                    var baseTokenUsd = GetClosestBaseTokenPrice(ts); 
                    
                    if (!baseTokenUsd.HasValue) continue;
                    priceUsd = priceFirstPerSecond.Value * baseTokenUsd.Value;
                }

                pricePoints.Add(new SwapPricePoint
                {
                    Timestamp = ts,
                    Price = priceUsd
                });
            }

            // 4. Save results
            pool.CountSwaps = countInRange;
            pool.PriceHistory = pricePoints
                .OrderBy(p => p.Timestamp)
                .ToList();

            var latest = pool.PriceHistory
                .OrderByDescending(p => p.Timestamp)
                .FirstOrDefault();
            
            pool.LatestPricePriceUsd = latest?.Price ?? 0;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Swaps] Error: {ex.Message}");
            pool.CountSwaps = 0;
            pool.LatestPricePriceUsd = 0;
        }
        finally
        {
            pool.IsSwapsLoading = false;
        }
    }


    private async void OnRefreshSwapsClicked()
    {
        // 1. Validation
        if (filters.MinTvlUsd < 1000m)
        {
            await DialogService.ShowMessageBox(
                "Warning",
                "To refresh Swaps Count, please set TVL filter to at least 1,000 USD.",
                yesText: "OK");
            return;
        }

        if (filteredPools.Count == 0) return;

        var fromDate = filters.SwapsFromDate;

        // 2. Reset UI state for all visible pools immediately
        foreach (var pool in filteredPools)
        {
            pool.IsSwapsLoading = true;
            pool.CountSwaps = 0;
            pool.LatestPricePriceUsd = 0;
            pool.PriceHistory.Clear();
        }
        StateHasChanged(); // Show spinners for everyone

        // 3. Pre-load wSOL price history once
        await BuildBaseTokenPriceHistoryAsync(fromDate);


        // 4. Sequential Execution Loop
        // We process pools one by one to avoid any race conditions or UI glitches.
        foreach (var pool in filteredPools)
        {
            // Process the current pool fully (Download -> Parse -> Calculate)
            await ProcessPoolSwapsAsync(pool, fromDate);

            // Update UI immediately after this pool is done.
            // This creates a smooth "row by row" unlocking effect.
            StateHasChanged();

            // Tiny yield to keep the browser responsive between rows
            await Task.Delay(1);
        }
    }

        private async Task BuildBaseTokenPriceHistoryAsync(DateTime? fromDate)
    {
        // Clear previous history
        _baseTokenUsdPriceHistory.Clear();

        string referencePoolAddress;
        string baseTokenAddress;
        string usdTokenAddress;

        if (selectedNetwork == Network.Solana)
        {
            referencePoolAddress = WsolUsdcPoolAddress;
            baseTokenAddress = "So11111111111111111111111111111111111111112"; // wSOL
            usdTokenAddress = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";  // USDC
        }
        else if (selectedNetwork == Network.Ethereum)
        {
            referencePoolAddress = WethUsdtPoolAddress;
            baseTokenAddress = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"; // wETH
            usdTokenAddress = "0xdAC17F958D2ee523a2206206994597C13D831ec7";  // USDT
        }
        else
        {
            return;
        }

        // Fetch swaps for the reference pool using the selected network
        var response = await SwapsService.GetPoolSwapsAsync(selectedNetwork, referencePoolAddress, 3000);
        if (response == null || response.Data.Count == 0)
            return;

        var from = fromDate?.Date ?? DateTime.MinValue;
        var to = DateTime.UtcNow;

        // Use a temporary list with initial capacity to minimize allocations
        var tempHistory = new List<SwapPricePoint>(response.Data.Count);

        foreach (var s in response.Data)
        {
            if (s.Timestamp < from || s.Timestamp > to)
                continue;

            decimal? price = null;

            // Calculate Base Token price in USD based on swap direction
            // Case 1: Selling Base (wSOL/wETH) for USD -> Price = USD amount / Base amount
            if (string.Equals(s.FromTokenAddress, baseTokenAddress, StringComparison.OrdinalIgnoreCase) &&
                string.Equals(s.ToTokenAddress, usdTokenAddress, StringComparison.OrdinalIgnoreCase) &&
                s.FromTokenAmount != 0)
            {
                price = s.ToTokenAmount / s.FromTokenAmount;
            }
            // Case 2: Buying Base (wSOL/wETH) with USD -> Price = USD amount / Base amount
            else if (string.Equals(s.FromTokenAddress, usdTokenAddress, StringComparison.OrdinalIgnoreCase) &&
                     string.Equals(s.ToTokenAddress, baseTokenAddress, StringComparison.OrdinalIgnoreCase) &&
                     s.ToTokenAmount != 0)
            {
                price = s.FromTokenAmount / s.ToTokenAmount;
            }

            if (price.HasValue)
            {
                tempHistory.Add(new SwapPricePoint
                {
                    Timestamp = s.Timestamp,
                    Price = price.Value
                });
            }
        }

        // CRITICAL: Sort by timestamp to enable Binary Search later
        _baseTokenUsdPriceHistory = tempHistory
            .OrderBy(x => x.Timestamp)
            .ToList();
    }


        private decimal? GetClosestBaseTokenPrice(DateTime timestamp)
    {
        // If list is empty
        if (_baseTokenUsdPriceHistory == null || _baseTokenUsdPriceHistory.Count == 0)
            return null;

        // Use BinarySearch for instant lookup
        int left = 0;
        int right = _baseTokenUsdPriceHistory.Count - 1;
        
        // Boundary checks
        if (timestamp <= _baseTokenUsdPriceHistory[left].Timestamp) return _baseTokenUsdPriceHistory[left].Price;
        if (timestamp >= _baseTokenUsdPriceHistory[right].Timestamp) return _baseTokenUsdPriceHistory[right].Price;

        // Classic Binary Search
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            var midVal = _baseTokenUsdPriceHistory[mid];

            if (midVal.Timestamp == timestamp)
                return midVal.Price;

            if (midVal.Timestamp < timestamp)
                left = mid + 1;
            else
                right = mid - 1;
        }

        // After loop, left and right point to closest neighbors.
        if (right < 0) right = 0;
        if (left >= _baseTokenUsdPriceHistory.Count) left = _baseTokenUsdPriceHistory.Count - 1;

        var valBefore = _baseTokenUsdPriceHistory[right];
        var valAfter = _baseTokenUsdPriceHistory[left];

        var diffBefore = (timestamp - valBefore.Timestamp).Duration();
        var diffAfter = (valAfter.Timestamp - timestamp).Duration();

        // Return price of the closer neighbor
        return diffBefore <= diffAfter ? valBefore.Price : valAfter.Price;
    }


    private void OnRefreshLatestPriceClicked()
    {
        // TODO: Implement arbitration flag / price diff refresh logic.
        Console.WriteLine("LatestPrice refresh clicked");
    }

    private string SelectedRowStyleFunc(PoolInfo pool, int rowNumber)
    {
        if (selectedPool != null && selectedPool.PoolAddress == pool.PoolAddress)
        {
            return "background-color: #E3F2FD;";
        }
        return string.Empty;
    }

    private string TruncateAddress(string address)
    {
        if (string.IsNullOrEmpty(address) || address.Length <= 12)
            return address;

        return $"{address[..6]}...{address[^4..]}";
    }
}
